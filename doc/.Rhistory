#pdf("../fig/cv_results.pdf", width=7, height=5)
plot(model_values, err_cv[,1], xlab="Interaction Depth", ylab="CV Error",
main="Cross Validation Error", type="n", ylim=c(0, 0.25))
points(model_values, err_cv[,1], col="blue", pch=16)
lines(model_values, err_cv[,1], col="blue")
arrows(model_values, err_cv[,1]-err_cv[,2], model_values, err_cv[,1]+err_cv[,2],
length=0.1, angle=90, code=3)
#dev.off()
}
model_best=model_values[1]
if(run.cv){
model_best <- model_values[which.min(err_cv[,1])]
}
par_best <- list(par=model_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
View(err_cv)
which.min(err_cv[,1])
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
fit_train <- train(dat_train, label_train, par_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par=par_best))
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par=par_best))
par_best$par
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
source('~/Dropbox/Tian_Teaching/G5243-ADS/0-Projects-startercodes/3-Spring2017/Project3_PoodleKFC/lib/train.R')
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
source('~/Dropbox/Tian_Teaching/G5243-ADS/0-Projects-startercodes/3-Spring2017/Project3_PoodleKFC/lib/train.R')
model_best=model_values[1]
if(run.cv){
model_best <- model_values[which.min(err_cv[,1])]
}
par_best <- list(depth=model_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
save(fit_train, file="../output/fit_train.RData")
tm_test=NA
if(run.test){
load(file=paste0("../output/feature_", "zip", "_", "test", ".RData"))
load(file="../output/fit_train.RData")
tm_test <- system.time(pred_test <- test(fit_train, dat_test))
save(pred_test, file="../output/pred_test.RData")
}
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
cat("Time for training model=", tm_train[1], "s \n")
cat("Time for making prediction=", tm_test[1], "s \n")
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
train_dir <- "../data/train_set/" # This will be modified for different data sets.
train_LR_dir <- paste(train_dir, "LR/", sep="")
train_HR_dir <- paste(train_dir, "HR/", sep="")
train_label_path <- paste(train_dir, "label.csv", sep="")
run.cv=TRUE # run cross-validation on the training set
K <- 5  # number of CV folds
run.feature.train=TRUE # process features for training set
run.test=TRUE # run evaluation on an independent test set
run.feature.test=TRUE # process features for test set
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
getwd()
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(train_LR_dir, train_HR_dir))
feat_train <- dat_train$feature
label_train <- dat_train$label
}
#save(dat_train, file="./output/feature_train.RData")
source("../lib/train.R")
source("../lib/test.R")
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(feat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(feat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(feat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
## Test code ##########
LR_dir <- "../data/train_set/LR/"
HR_dir <- "../data/train_set/HR/"
n_files <- length(list.files(LR_dir))
n_points=1000
### store feature and responses
featMat <- array(NA, c(n_files * n_points, 8, 3))
dim(featMat)
### read LR/HR image pairs
for(i in 1:1){  #[todo] n_files){
imgLR <- readImage(paste0(LR_dir,  "img_", sprintf("%04d", i), ".jpg"))
imgHR <- readImage(paste0(HR_dir,  "img_", sprintf("%04d", i), ".jpg"))
### step 1. sample n_points from imgLR
### step 2. for each sampled point in imgLR,
### step 2.1. save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
### step 2.2. save the corresponding 4 sub-pixels of imgHR in labMat
### step 3. repeat above for three channels
}
dim(imgLR)
rm(list = ls())
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
set.seed(2018)
setwd("../")
# here replace it with your own path or manually set it in RStudio to where this rmd file is located.
# use relative path for reproducibility
train_dir <- "../data/train_set/" # This will be modified for different data sets.
train_LR_dir <- paste(train_dir, "LR/", sep="")
train_HR_dir <- paste(train_dir, "HR/", sep="")
train_label_path <- paste(train_dir, "label.csv", sep="")
run.cv=TRUE # run cross-validation on the training set
K <- 5  # number of CV folds
run.feature.train=TRUE # process features for training set
run.test=TRUE # run evaluation on an independent test set
run.feature.test=TRUE # process features for test set
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
source("../lib/feature3.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(train_LR_dir, train_HR_dir))
feat_train <- dat_train$feature
label_train <- dat_train$label
}
#save(dat_train, file="./output/feature_train.RData")
source("../lib/train.R")
source("../lib/test.R")
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(feat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir, HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir, HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(LR_dir, HR_dir, fit_train))
}
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
#cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
cat("Time for training model=", tm_train[1], "s \n")
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
#cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
#cat("Time for training model=", tm_train[1], "s \n")
cat("Time for super-resolution=", tm_test[1], "s \n")
### Author: Chengliang Tang
### Project 3
LR_dir <- "/Users/siyuzhu/Documents/Github/ADS/Fall2018-Proj3-Sec2--sec2proj3_grp2/data/train_set/LR/"
HR_dir <- "/Users/siyuzhu/Documents/Github/ADS/Fall2018-Proj3-Sec2--sec2proj3_grp2/data/train_set/HR/"
locate <- function(n, ncol) {
row <- floor(n/ncol) + 1
col <- n - ncol * (row - 1)
# corner case
if(col == 0) {
row = row - 1
col = ncol
}
return(c(row, col))
}
find <- function(loc, matrix) {
return(matrix[loc[1], loc[2]])
}
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
i =1
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
LR_nrow <- nrow(imgLR)
LR_ncol <- ncol(imgLR)
num_ele <- LR_nrow * LR_ncol
featMat <- array(NA, c(num_ele, 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
ele_locations <- t(sapply(1 : num_ele, locate, LR_ncol))
new_locations <- ele_locations + 1
for (k in c(1:3)) {
# supplementary image matrix
supp_imgLR <- cbind(imgLR[, 1, k], imgLR[, , k], imgLR[, LR_ncol, k])
supp_imgLR <- rbind(cbind(imgLR[1, 1, k], imgLR[1, , k],imgLR[1, LR_ncol, k]),
supp_imgLR, cbind(imgLR[LR_nrow, 1, k], imgLR[LR_nrow, , k],imgLR[LR_nrow, LR_ncol, k]))
### fill the featM
# j = 1
loc1 <- cbind(new_locations[, 1] - 1, new_locations[, 2] - 1)
featMat[,  1, k] <- apply(loc1, 1, find, matrix = supp_imgLR)
# j = 2
loc2 <- cbind(new_locations[, 1] - 1, new_locations[, 2])
featMat[,  2, k] <- apply(loc2, 1, find, matrix = supp_imgLR)
# j = 3
loc3 <- cbind(new_locations[, 1] - 1, new_locations[, 2] + 1)
featMat[,  3, k] <- apply(loc3, 1, find, matrix = supp_imgLR)
# j = 4
loc4 <- cbind(new_locations[, 1], new_locations[, 2] - 1)
featMat[,  4, k] <- apply(loc4, 1, find, matrix = supp_imgLR)
# j = 5
loc5 <- cbind(new_locations[, 1], new_locations[, 2] + 1)
featMat[,  5, k] <- apply(loc5, 1, find, matrix = supp_imgLR)
# j = 6
loc6 <- cbind(new_locations[, 1] + 1, new_locations[, 2] - 1)
featMat[,  6, k] <- apply(loc6, 1, find, matrix = supp_imgLR)
# j = 7
loc7 <- cbind(new_locations[, 1] + 1, new_locations[, 2])
featMat[,  7, k] <- apply(loc7, 1, find, matrix = supp_imgLR)
# j = 8
loc8 <- cbind(new_locations[, 1] + 1, new_locations[, 2] + 1)
featMat[,  8, k] <- apply(loc8, 1, find, matrix = supp_imgLR)
#featMat[,  , k] <- t(apply(new_locations, 1, distribute1, img = supp_imgLR))
#########
#print(paste("k = ", k, sep = ""))
}
### step 2. apply the modelList over featMat
predMat <- test(modelList = fit_train, featMat)
### step 3. recover high-resolution from predMat and save in HR_dir
imgHR_fit <- readImage(paste0(HR_dir,  "img_", sprintf("%04d", i), ".jpg"))
base_row <- seq(1, 2 * LR_nrow, 2)
base_col <- seq(1, 2 * LR_ncol, 2)
imgHR_fit[base_row, base_col, ] <- predMat[, 1, ]
imgHR_fit[base_row, base_col + 1, ] <- predMat[, 2, ]
imgHR_fit[base_row + 1, base_col, ] <- predMat[, 3, ]
imgHR_fit[base_row + 1, base_col + 1, ] <- predMat[, 4, ]
display(imgHR_fit)
display(imgHR_fit)
rm(list = ls())
train_dir <- "../data/train_set/" # This will be modified for different data sets.
train_LR_dir <- paste(train_dir, "LR/", sep="")
train_HR_dir <- paste(train_dir, "HR/", sep="")
train_label_path <- paste(train_dir, "label.csv", sep="")
run.cv=TRUE # run cross-validation on the training set
K <- 5  # number of CV folds
run.feature.train=TRUE # process features for training set
run.test=TRUE # run evaluation on an independent test set
run.feature.test=TRUE # process features for test set
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
source("../lib/feature3.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(train_LR_dir, train_HR_dir))
feat_train <- dat_train$feature
label_train <- dat_train$label
}
#save(dat_train, file="./output/feature_train.RData")
dim(feat_train)
source("../lib/train.R")
source("../lib/test.R")
dim(label_train)
y.train <- label_train
X.train <- feat_train
n <- dim(y.train)[1]
n.fold <- floor(n/K)
n.fold
K
s <- sample(rep(1:K, c(rep(n.fold, K-1), n-(K-1)*n.fold)))
s
cv.error <- rep(NA, K)
cv.error
par <- list(depth=d)
d = 3
par <- list(depth=d)
par
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(feat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
if(run.cv){
load("../output/err_cv.RData")
plot(model_values, err_cv[,1], xlab="Interaction Depth", ylab="CV Error",
main="Cross Validation Error", type="n", ylim=c(0, 0.25))
points(model_values, err_cv[,1], col="blue", pch=16)
lines(model_values, err_cv[,1], col="blue")
arrows(model_values, err_cv[,1]-err_cv[,2], model_values, err_cv[,1]+err_cv[,2],
length=0.1, angle=90, code=3)
}
err_cv
model_best=model_values[1]
model_best
model_values
model_best=model_values[1]
if(run.cv){
model_best <- model_values[which.min(err_cv[,1])]
}
par_best <- list(depth=model_best)
model_best
par_best
tm_train=NA
tm_train <- system.time(fit_train <- train(feat_train, label_train, par_best))
save(fit_train, file="../output/fit_train.RData")
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
test_LR_dir
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
LR_dir
### Author: Chengliang Tang
### Project 3
LR_dir <- "/Users/siyuzhu/Documents/Github/ADS/Fall2018-Proj3-Sec2--sec2proj3_grp2/data/train_set/LR/"
HR_dir <- "/Users/siyuzhu/Documents/Github/ADS/Fall2018-Proj3-Sec2--sec2proj3_grp2/data/train_set/HR/"
locate <- function(n, ncol) {
row <- floor(n/ncol) + 1
col <- n - ncol * (row - 1)
# corner case
if(col == 0) {
row = row - 1
col = ncol
}
return(c(row, col))
}
find <- function(loc, matrix) {
return(matrix[loc[1], loc[2]])
}
superResolution <- function(LR_dir, HR_dir, modelList = fit_train){
### Construct high-resolution images from low-resolution images with trained predictor
### Input: a path for low-resolution images + a path for high-resolution images
###        + a list for predictors
### load libraries
library("EBImage")
n_files <- length(list.files(LR_dir))
### read LR/HR image pairs
for(i in 1:n_files){
imgLR <- readImage(paste0(LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
LR_nrow <- nrow(imgLR)
LR_ncol <- ncol(imgLR)
num_ele <- LR_nrow * LR_ncol
featMat <- array(NA, c(num_ele, 8, 3))
### step 1. for each pixel and each channel in imgLR:
###           save (the neighbor 8 pixels - central pixel) in featMat
###           tips: padding zeros for boundary points
ele_locations <- t(sapply(1 : num_ele, locate, LR_ncol))
new_locations <- ele_locations + 1
for (k in c(1:3)) {
# supplementary image matrix
supp_imgLR <- cbind(imgLR[, 1, k], imgLR[, , k], imgLR[, LR_ncol, k])
supp_imgLR <- rbind(cbind(imgLR[1, 1, k], imgLR[1, , k],imgLR[1, LR_ncol, k]),
supp_imgLR, cbind(imgLR[LR_nrow, 1, k], imgLR[LR_nrow, , k],imgLR[LR_nrow, LR_ncol, k]))
### fill the featM
# j = 1
loc1 <- cbind(new_locations[, 1] - 1, new_locations[, 2] - 1)
featMat[,  1, k] <- apply(loc1, 1, find, matrix = supp_imgLR)
# j = 2
loc2 <- cbind(new_locations[, 1] - 1, new_locations[, 2])
featMat[,  2, k] <- apply(loc2, 1, find, matrix = supp_imgLR)
# j = 3
loc3 <- cbind(new_locations[, 1] - 1, new_locations[, 2] + 1)
featMat[,  3, k] <- apply(loc3, 1, find, matrix = supp_imgLR)
# j = 4
loc4 <- cbind(new_locations[, 1], new_locations[, 2] - 1)
featMat[,  4, k] <- apply(loc4, 1, find, matrix = supp_imgLR)
# j = 5
loc5 <- cbind(new_locations[, 1], new_locations[, 2] + 1)
featMat[,  5, k] <- apply(loc5, 1, find, matrix = supp_imgLR)
# j = 6
loc6 <- cbind(new_locations[, 1] + 1, new_locations[, 2] - 1)
featMat[,  6, k] <- apply(loc6, 1, find, matrix = supp_imgLR)
# j = 7
loc7 <- cbind(new_locations[, 1] + 1, new_locations[, 2])
featMat[,  7, k] <- apply(loc7, 1, find, matrix = supp_imgLR)
# j = 8
loc8 <- cbind(new_locations[, 1] + 1, new_locations[, 2] + 1)
featMat[,  8, k] <- apply(loc8, 1, find, matrix = supp_imgLR)
#featMat[,  , k] <- t(apply(new_locations, 1, distribute1, img = supp_imgLR))
#########
#print(paste("k = ", k, sep = ""))
}
### step 2. apply the modelList over featMat
predMat <- test(modelList = fit_train, featMat)
### step 3. recover high-resolution from predMat and save in HR_dir
imgHR_fit <- readImage(paste0(HR_dir,  "img_", sprintf("%04d", i), ".jpg"))
base_row <- seq(1, 2 * LR_nrow, 2)
base_col <- seq(1, 2 * LR_ncol, 2)
imgHR_fit[base_row, base_col, ] <- predMat[, 1, ]
imgHR_fit[base_row, base_col + 1, ] <- predMat[, 2, ]
imgHR_fit[base_row + 1, base_col, ] <- predMat[, 3, ]
imgHR_fit[base_row + 1, base_col + 1, ] <- predMat[, 4, ]
display(imgHR_fit)
}
}
superResolution(LR_dir, HR_dir, modelList = fit_train)
### step 3. recover high-resolution from predMat and save in HR_dir
imgHR_fit <- readImage(paste0(HR_dir,  "img_", sprintf("%04d", i), ".jpg"))
dim(imgHR)_fit
dim(imgHR)_fit)
dim(imgHR_fit)
getwd()
knitr::opts_chunk$set(
echo = TRUE,
dev = "png",
dpi = 150,
fig.align = "center",
comment = NA
)
library(rstan)
library(dplyr)
library(lubridate)
library(ggplot2)
library(bayesplot)
theme_set(bayesplot::theme_default())
print_file <- function(file) {
cat(paste(readLines(file), "\n", sep=""), sep="")
}
# seed for R's pseudo-random number generators, not Stan's
set.seed(1123)
pest_data <- readRDS('/Users/siyuzhu/Downloads/pest_data.RDS')
head(pest_data)
head(pest_data)
